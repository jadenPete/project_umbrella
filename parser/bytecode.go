/*
 * Bytecode Translation:
 *
 * The bytecode translator is responsible for converting the AST generated by the parser into a list
 * of bytecode instructions and associated constant values (referred to as the constant list).
 * Values generated by instructions have an implicit value ID which increments and begins at 0.
 * Collectively, these values are referred to as the value list.
 *
 * Built-in values are negative; the following are accessible.
 * - print (-1)
 * - println (-2)
 *
 * Likewise, built-in methods are negative; the following are accessible.
 * - __to_str__ (-1)
 *
 * The following instructions (listed alongside their IDs and parameters) are available.
 *
 * PUSH_ARG (1) (VAL_ID):
 * 	Push VAL_ID to the argument stack to be passed to the next called function. Sequentially, the
 * 	argument stack can be thought of as being cleared on every function call.
 *
 * VAL_FROM_CALL (2) (VAL_ID):
 * 	Call the function referred to by VAL_ID with the arguments in the argument stack and push the
 * 	returned value to the value list.
 *
 * 	If VAL_ID doesn't refer to a function, the runtime will panic.
 *
 * VAL_FROM_CONST (3) (CONST_ID):
 * 	Retrieve the constant `CONST_ID` from the constant list and push it to the value list.
 *
 * VAL_FROM_STRUCT_VAL (4) (VAL_ID, FIELD_ID):
 * 	Retrieve the field identified by FIELD_ID from the struct instance referred to by VAL_ID,
 * 	pushing it to the value list.
 *
 * 	If VAL_ID doesn't refer to a struct instance, the runtime will panic.
 */
package parser

import (
	"crypto/sha256"
	"fmt"

	"github.com/ugorji/go/codec"

	"project_umbrella/interpreter/common"
)

const ChecksumSize = 32

var builtinValues = map[string]int{
	"print":   -1,
	"println": -2,
}

func sourceChecksum(fileContent string) [ChecksumSize]byte {
	return sha256.Sum256([]byte(fileContent))
}

type Bytecode struct {
	sourceChecksum [ChecksumSize]byte
	Constants      []Constant
	Instructions   []*Instruction
}

func DecodeBytecode(encoded []byte) *Bytecode {
	var handle codec.MsgpackHandle

	bytecode := &Bytecode{}

	codec.NewDecoderBytes(encoded, &handle).Decode(bytecode)

	return bytecode
}

func (bytecode *Bytecode) Encode() []byte {
	var handle codec.MsgpackHandle
	var output []byte

	if codec.NewEncoderBytes(&output, &handle).Encode(
		&map[string]interface{}{
			"constants":    bytecode.Constants,
			"instructions": bytecode.Instructions,
		},
	) != nil {
		panic("Internal parser error: Couldn't encode the resulting bytecode.")
	}

	return output
}

type BytecodeTranslator struct {
	constantIdMap        map[Constant]int
	constantValueIdMap   map[int]int
	identifierValueIdMap map[string]int
	nextValueId          int
	instructions         []*Instruction
}

func NewBytecodeTranslator() *BytecodeTranslator {
	return &BytecodeTranslator{
		constantIdMap:        make(map[Constant]int),
		constantValueIdMap:   make(map[int]int),
		identifierValueIdMap: make(map[string]int),
		nextValueId:          0,
		instructions:         make([]*Instruction, 0),
	}
}

func (translator *BytecodeTranslator) generateBytecode(fileContent string) *Bytecode {
	bytecode := &Bytecode{
		sourceChecksum: sourceChecksum(fileContent),
		Constants:      make([]Constant, 0, len(translator.constantIdMap)),
		Instructions:   translator.instructions,
	}

	constantsSet := make([]bool, 0, len(translator.constantIdMap))

	for constant, i := range translator.constantIdMap {
		if i >= len(bytecode.Constants) {
			bytecode.Constants = common.Resize(bytecode.Constants, i+1)
		}

		if i >= len(constantsSet) {
			constantsSet = common.Resize(constantsSet, i+1)
		}

		bytecode.Constants[i] = constant

		constantsSet[i] = true
	}

	for _, isSet := range constantsSet {
		if !isSet {
			panic("Internal parser error: Nonexhaustive constant ID map.")
		}
	}

	return bytecode
}

func (translator *BytecodeTranslator) ExpressionToBytecode(
	expression Expression,
	fileContent string,
) *Bytecode {
	var expressionList *ExpressionListExpression

	expression.Visit(ExpressionVisitor{
		VisitAssignment: func(_ *AssignmentExpression) {},
		VisitCall:       func(_ *CallExpression) {},
		VisitIdentifier: func(_ *IdentifierExpression) {},
		VisitString:     func(_ *StringExpression) {},
		VisitExpressionListExpression: func(visitedExpressionList *ExpressionListExpression) {
			expressionList = visitedExpressionList
		},
	})

	if expressionList == nil {
		panic("Internal parser error: Expected an expression list, but got a different expression.")
	}

	for _, subexpression := range expressionList.Children {
		translator.valueIdForExpression(subexpression)
	}

	return translator.generateBytecode(fileContent)
}

func (translator *BytecodeTranslator) valueIdForAssignment(assignment *AssignmentExpression) int {
	valueID := translator.valueIdForExpression(assignment.Value)

	if _, ok := translator.identifierValueIdMap[assignment.Name.Content]; ok {
		panic("Reassigning to an already declared value is impossible.")
	}

	translator.identifierValueIdMap[assignment.Name.Content] = valueID

	return valueID
}

func (translator *BytecodeTranslator) valueIdForCall(call *CallExpression) int {
	identifierValueID := translator.valueIdForIdentifier(call.Identifier)
	argumentValueID := translator.valueIdForExpression(call.Argument)

	translator.instructions = append(
		translator.instructions,
		&Instruction{
			Type:      PushArgumentInstruction,
			Arguments: []int{argumentValueID},
		},

		&Instruction{
			Type:      ValueFromCallInstruction,
			Arguments: []int{identifierValueID},
		},
	)

	result := translator.nextValueId

	translator.nextValueId++

	return result
}

func (translator *BytecodeTranslator) valueIdForConstant(constant Constant) int {
	var constantID int

	if result, ok := translator.constantIdMap[constant]; ok {
		constantID = result
	} else {
		constantID = len(translator.constantIdMap)

		translator.constantIdMap[constant] = constantID
	}

	var valueID int

	if result, ok := translator.constantValueIdMap[constantID]; ok {
		valueID = result
	} else {
		translator.instructions = append(translator.instructions, &Instruction{
			Type:      ValueFromConstantInstruction,
			Arguments: []int{constantID},
		})

		valueID = translator.nextValueId

		translator.nextValueId++
		translator.constantValueIdMap[constantID] = valueID
	}

	return valueID
}

func (translator *BytecodeTranslator) valueIdForExpression(expression Expression) int {
	var result int

	expression.Visit(ExpressionVisitor{
		VisitAssignment: func(assignment *AssignmentExpression) {
			result = translator.valueIdForAssignment(assignment)
		},

		VisitExpressionListExpression: func(expressionList *ExpressionListExpression) {
			panic("Encountered a non-top level expression list.")
		},

		VisitCall: func(call *CallExpression) {
			result = translator.valueIdForCall(call)
		},

		VisitIdentifier: func(identifier *IdentifierExpression) {
			result = translator.valueIdForIdentifier(identifier)
		},

		VisitString: func(string_ *StringExpression) {
			result = translator.valueIdForConstant(Constant{
				Type:    StringConstant,
				Encoded: string_.Content,
			})
		},
	})

	return result
}

func (translator *BytecodeTranslator) valueIdForIdentifier(identifier *IdentifierExpression) int {
	if valueID, ok := translator.identifierValueIdMap[identifier.Content]; ok {
		return valueID
	}

	if valueID, ok := builtinValues[identifier.Content]; ok {
		return valueID
	}

	panic(fmt.Sprintf("Unknown value: %s", identifier.Content))
}

type Constant struct {
	Type    ConstantType
	Encoded string
}

type ConstantType int

const StringConstant ConstantType = iota + 1

type Instruction struct {
	Type      InstructionType
	Arguments []int
}

type InstructionType int

const (
	PushArgumentInstruction InstructionType = iota + 1
	ValueFromCallInstruction
	ValueFromConstantInstruction
	ValueFromStructValueInstruction
)
